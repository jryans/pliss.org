<%include file="header.inc" args="title='Lectures'"/>

		<!-- Main -->
			<section id="main" class="wrapper">
				<div class="container">

					<header class="major special">
						<h2>Lectures</h2>
						<p></p>
					</header>

                    <div class="content">

                        <header>
                            <h4></h4>
                            <p>Emery Berger</p>
                        </header>
                        <p>
                        </p>

                        <hr>

                        <header>
                            <h4></h4>
                            <p>Cristian Cadar</p>
                        </header>
                        <p>
                        </p>

                        <hr>

                        <header>
                            <h4>Secrets from Inside the OpenJDK Java Virtual
                            Machine <span class="and">and</span> Everything you want to know about
                            garbage collection but were afraid to ask</h4>
                            <p>Christine H. Flood</p>
                        </header>
                        <p>
                        The first talk will be some details of how the innards of
                        the JVM works.  This might be helpful to folks looking to
                        implement their own languages either from scratch or on top
                        of the JVM.  The second talk will be a deep dive into
                        garbage collection inluding work I've done on Lisp, Id, and
                        Java implementations.
                        </p>

                        <hr>

                        <header>
                            <h4></h4>
                            <p>Jeffrey S. Foster</p>
                        </header>
                        <p>
                        </p>

                        <hr>

                        <header>
                            <h4>Software innards: linking, loading and
                            other mysteries <span class="and">and</span> Composing the uncomposable:
                            past, present and emerging approaches to language
                            interoperability</h4>
                            <p>Stephen Kell</p>
                        </header>
                        <p>
                        (1) I will talk about the entrails of software: linking
                        and loading of machine code. This will include their
                        history from the earliest stored-program computers,
                        through to their place in modern toolchains and why
                        they're not yet solved problems. Not unrelatedly, I'll
                        also cover differing approaches to implementing
                        interactive debugging. (2) I will talk about language
                        interoperability from an implementer's perspective,
                        visiting several different incarnations of the problem:
                        traditional link-time cases, cases faced by
                        ahead-of-time compilation of modern languages, and
                        cases involving language virtual machines.
                        </p>

                        <hr>

                        <header>
                            <h4>Scripting languages <span class="and">and</span> Syntactic sugar</h4>
                            <p>Shriram Krishnamurthi</p>
                        </header>
                        <p>
                        </p>

                        <hr>

                        <header>
                            <h4>Beyond polyhedra: emerging compiler techniques for optimizing irregular programs</h4>
                            <p>Milind Kulkarni</p>
                        </header>
                        <p>
                        In these lectures, I will focus on the problem of
                        compile-time scheduling optimizations that restructure
                        computations to improve locality and parallelims.
                        Traditional approaches to this problem reason about
                        loop structures and schedules in terms of polyhedra,
                        but there has been little success in extending such
                        approaches beyond loop-based programs. I will start by
                        briefly introducing the basic concepts used in
                        reasoning about and transforming loop programs. I will
                        then argue that there are interesting scheduling
                        transformations that can be done for nonâ€“loop based
                        programs, in particular recursive traversla programs
                        such as those that arise in graphics, data mining, and
                        simulation. I will survey recent work from the last
                        decade on designing and implementing these
                        transformations. Then, I will discuss recent advances
                        in developing unified frameworks for representing,
                        reasoning about, and transforming programs that deal
                        with loops and recursion. Time permitting, we will also
                        use one of these frameworks to explore and design a new
                        transformation for recursive programs.
                        </p>

                        <hr>

                        <header>
                            <h4>Asynchronous Programming: Challenges and Research Opportunities</h4>
                            <p>Frank Tip</p>
                        </header>
                        <p>
                        </p>

                        <hr>

                        <header>
                            <h4>Language design for industrial scale</h4>
                            <p>Julien Verlaguet</p>
                        </header>
                        <p>
                        </p>

                        <hr>

                        <header>
                            <h4>Declare Your Language</h4>
                            <p>Eelco Visser</p>
                        </header>
                        <p>
                        Language workbenches support the high-level definition
                        of (domain-specific) programming languages by means of
                        meta-languages and the automatic derivation of
                        implementations from such definitions. A declarative
                        meta-language allows the language designer to abstract
                        from irrelevant implementation details and focus on the
                        essence of a language. In these lectures I will talk
                        about the design and semantics of two meta-languages
                        (from the Spoofax language workbench) for the
                        definition of syntax and static semantics. The lectures
                        will cover three topics: (1) Declarative syntax
                        definition with SDF3: the extension of context-free
                        grammars to syntax definitions by means of features
                        such as constructors, layout templates, lexical syntax,
                        and declarative disambiguation. (2) Name binding and
                        resolution with scope graphs: the definition of a
                        framework for the representation of a wide range of
                        name binding rules, including (mutually recursive)
                        modules and imports. (3) Type system definition with
                        Statix: the interaction between name and type
                        resolution and the scheduling of name resolution
                        queries. 
                        </p>

                    </div>

				</div>
			</section>

<%include file="footer.inc" />
