<%include file="header.inc" args="title='Lectures'"/>

		<!-- Main -->
			<section id="main" class="wrapper">
				<div class="container">

					<header class="major special">
						<h2>Lectures</h2>
						<p></p>
					</header>

                    <div class="content">

                        <header>
                            <h4>Compiler Bugs: Detecting Them and Understanding Their Impact
                            <span class="and">and</span>
                            Dynamic Symbolic Execution with KLEE
                            </h4>
                            <p>Cristian Cadar</p>
                        </header>
                        <p>
                        (1) In this talk, I will first describe the challenges of meaningfully
                        testing compilers, and then survey some of the main techniques that have
                        been successfully applied in this space.  I will also discuss the impact
                        of compiler bugs from several perspectives: the security risks of
                        compiler bugs, the extent to which they affect the correctness of
                        deployed software, and the difficulty of debugging software affected by
                        them.  The talk is primarily targeted to those who are new to the area
                        of compiler testing, but it will also include several parts useful to a
                        more specialist audience.
                        </p>
                        <p>
                        (2) Dynamic symbolic execution has gathered a lot of attention in recent
                        years as an effective technique for generating high-coverage test suites
                        and finding deep errors in complex software applications. In this
                        tutorial-style presentation, I will introduce the main concepts of
                        dynamic symbolic execution and exemplify them in the context of our KLEE
                        symbolic execution infrastructure. The talk is primarily targeted to
                        those who have no direct experience with dynamic symbolic execution and
                        KLEE, but the talk will also include several parts useful to a more
                        specialist audience.
                        </p>

                        <hr>

                        <header>
                            <h4>Easy SSA Building - C2 Style
                            <span class="and">and</span>
                            High Performance from understanding the Low Levels
                            </h4>
                            <p>Cliff Click</p>
                        </header>
                        <p>
                        (1) How the HotSpot C2 JIT builds and optimizes SSA
                        form quickly and simply. No fancy algorithm needed!
                        </p>
                        <p>
                        (2) A talk on X86 processor performance, with a live
                        code-along session looking at the performance tradeoff
                        between Bandwidth and Garbage Collection. Bring your
                        laptop & fav Java IDE; Java code and ~2.7G dataset
                        provided.
                        </p>

                        <hr>

                        <header>
                            <h4>Sparse abstract interpretation for compilers</h4>
                            <p>Laure Gonnord</p>
                        </header>
                        <p></p>

                        <hr>


                        <header>
                            <h4>What should a programming language implementation be?
                            <span class="and">and</span>
                            Where the wild pointers are
                            </h4>
                            <p>Stephen Kell</p>
                        </header>
                        <p>(1) A box that goes fast? A comfortable space to work in? A
                        unifying overlord that "rules" all software? An
                        obedient servant? An intelligent collaborator? A window
                        onto a wider world?
                        In this relatively high-level lecture I'll examine different attitudes to
                        this question, as manifest in different real language implementations over
                        history, and use these to explain or hypothesise some directions of ongoing
                        and future work. One theme will be how the goal of serving human beings is,
                        curiously, slipping further down the agenda even while machine resources
                        are more plentiful than ever.
                        </p>
                        <p>
                        (2) "A linker, a debugger and a garbage collector walked into a bar,
                        all looking for the manager."

                        In this relatively low-level lecture
                        I'll cover why these systems are all different facets of the same
                        strangely-shaped coin,
                        why the folklore dichotomy of "managed vs unmanaged"
                        is obscuring useful points in the design space,
                        why this is hurting our ability to build tools
                        and offer usable interoperability among languages/implementations,
                        and one possible evolutionary approach for doing better.

                        An emergent theme will be that language implementations are arguably
                        in need of an "hourglass architecture" rather like the Internet's,
                        and that handling of pointers, in their many guises, is the main unresolved challenge.
                        </p>

                        <hr>

                        <header>
                            <h4>Beyond polyhedra: optimizing irregular programs</h4>
                            <p>Milind Kulkarni</p>
                        </header>
                        <p>
                        In these lectures, I will focus on the problem of
                        compile-time scheduling optimizations that restructure
                        computations to improve locality and parallelims.
                        Traditional approaches to this problem reason about
                        loop structures and schedules in terms of polyhedra,
                        but there has been little success in extending such
                        approaches beyond loop-based programs. I will start by
                        briefly introducing the basic concepts used in
                        reasoning about and transforming loop programs. I will
                        then argue that there are interesting scheduling
                        transformations that can be done for nonâ€“loop based
                        programs, in particular recursive traversla programs
                        such as those that arise in graphics, data mining, and
                        simulation. I will survey recent work from the last
                        decade on designing and implementing these
                        transformations. Then, I will discuss recent advances
                        in developing unified frameworks for representing,
                        reasoning about, and transforming programs that deal
                        with loops and recursion. Time permitting, we will also
                        use one of these frameworks to explore and design a new
                        transformation for recursive programs.
                        </p>

                    </div>

				</div>
			</section>

<%include file="footer.inc" />
